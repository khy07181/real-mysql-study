## 함수 기반 인덱스

- 컬럼의 값을 변형한 값에 대해 인덱스를 구축하는 것


가상 컬럼을 이용한 인덱스
- 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다

```sql
ALTER TABLE user  
    ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,  
    ADD INDEX ix_fullname (full_name);
```

함수를 이용한 인덱스
- 테이블 구조를 변경하지 않고, 함수를 직접 사용하d는 인덱스

```sql
CREATE TABLE user  
(  
    user_id    BIGINT,  
    first_name VARCHAR(10),  
    last_name  VARCHAR(10),  
    PRIMARY KEY (user_id),  
    INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))  
);
```

## 멀티 밸류 인덱스

- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
- 멀티 밸류 인덱스를 활용하기 위해서는 반드시 다음 함수들을 이용해 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.
	- `MEMBER OF()`
	- `JSON_CONTAINS()`
	- `JSON_OVERLAPS()`

## 클러스터링 인덱스

- 테이블의 PK에 대해서만 적용되는 내용으로, PK 값이 비슷한 레코들끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 한다.
	- PK 값에 의해 레코드의 저장 위치가 결정된다.
	- PK가 변경되면 물리적인 저장 위치가 변경된다.
- 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.
- PK가 없는 테이블의 경우 다음과 같은 우선순위대로 PK를 대체할 컬럼을 선택한다.
	1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
	2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택
	3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택
- 클러스터링 테이블의 모든 세컨더리 인덱스는 해당 레코드의 저장된 주소가 아니라 PK 값을 저장하도록 구현돼 있다.
	- MyISAM : 인덱스를 검색해서 레코드의 주소를 확인 후, 레코드의 주소를 이용해 최종 레코드 가져옴
	- InnoDB : 인덱스를 검색해서 PK 값을 확인 후 PK 인덱스를 검색해서 최종 레코드 가져옴

pros
- PK 검색 시 처리 성능이 매우 빠름
- 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.
	- 커버링 인덱스

cons
- 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 클러스터링 키 값이 크기가 클 경우 전체 인덱스의 크기가 커진다.
- 세컨더리 인덱스를 통해 검색할 때 PK로 다시 검색해서 처리 성능이 느리다.
- INSERT 시 PK에로 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다.
- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하므로 처리 성능이 느리다.

### 클러스터링 테이블 사용 시 주의사항

- 클러스터링 인덱스 키의 크기
	- 모든 세컨더리 인덱스가 PK를 포함하기 떄문에 PK 크기가 커지면 세컨더리 인덱스도 자동으로 커진다.
	- PK를 신중하게 선택헤야 한다.
- PK는 AUTO_INCREMENT보다 업무적인 컬럼으로 생성
	- PK가 매우 중요한 역할을 하기 때문에 대부분의 검색에서 빈번하게 사용되는 것이 일반적
	- 컬럼의 크기가 크더라도 업무적으로 레코드를 대표할 수 있다면 유의미한 PK를 설정하는 것이 좋다.
- PK는 반드시 명시적으로 설정
- PK가 길어질 경우 세컨더리 인덱스가 필요하지 않다면 사용해도 좋지만 필요하다면 인조 식별자(AUTO_INCREMENT)를 추가하는 것이 좋다.

## 유니크 인덱스

- 일반 세컨더리 인덱스와 구조상 아무런 차이점이 없다.
	- 제약조건의 차이

### 유니크 인덱스 읽기

- 유니크 인덱스가 빠른 것처럼 보이지만 중복을 허용하지 않아 읽은 레코드의 수가 적을 뿐 성능이 크게 차이나진 않는다.

### 유니크 인덱스 쓰기

- 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는 지 확인하기 때문에 유니크 하지 않은 인덱스보다 느리다.
- 중복을 체크할 때는 읽기 잠금, 쓸 때는 쓰기 잠금을 사용하는 과정에서 데드락이 빈번히 발생한다.

### 유니크 인덱스 주의사항

- 성능 개선을 위해 불필요하게 유니크 인덱스를 생성하지 않는 것이 좋다.
- 같이 컬럼의 세컨더리 인덱스나 PK와 동일하게 유니크 인덱스를 생성하는 경우 인덱스 관점에서는 불필요한 중복이다.

## 외래키

- InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스도 생성된다.
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.
- 부모 테이블의 데이터 삭제 시 자식 테이블의 FK 레코드도 함께 삭제된다.
