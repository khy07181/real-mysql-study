# Week 03 정리

## 디스크 I/O

- 데이터가 컴퓨터의 두뇌인 CPU/메모리와 저장소인 디스크(HDD/SSD) 사이를 오가는 행위
- Input (Read): 디스크에 있는 데이터를 메모리로 읽어옴
- Output (Write): 메모리에 있는 데이터를 디스크에 저장

### HDD vs SSD

- **HDD (Hard Disk Drive)**: 물리적으로 회전하는 디스크에서 헤드가 움직이며 데이터를 읽고 씀. 랜덤 I/O에서 헤드 이동 시간 때문에 느림
- **SSD (Solid State Drive)**: 전자적으로 데이터에 접근하므로 물리적 이동이 없음. HDD보다 랜덤 I/O가 훨씬 빠르지만, 여전히 순차 I/O가 더 효율적

### 순차 I/O vs 랜덤 I/O

디스크 I/O는 데이터를 읽고 쓰는 방식에 따라 두가지로 나뉨

#### 순차 I/O (Sequential I/O)

- 디스크의 기록 장치(헤드)가 시작 위치로 한 번 이동한 다음, 데이터를 **끊기지 않고 쭉 이어서** 읽거나 씀
- 디스크 헤드의 이동 횟수가 적어 **빠름**
- **Full Table Scan**(풀 테이블 스캔)이나 **로그 기록**(Binlog)을 할 때 주로 발생

#### 랜덤 I/O (Random I/O)

- 데이터를 읽을 때마다 디스크 헤드가 이곳저곳 **흩어진 위치(주소)로 이동**해서 데이터를 읽거나 씀
- 디스크 헤드가 계속 움직여야 하므로 순차 I/O보다 **훨씬 느림**

## 페이지(Page)

디스크와 메모리(버퍼풀) 사이에 데이터를 주고받을 때 사용하는 기본 단위

- 사용자가 단 1건의 데이터(row)만 필요로 해도, 데이터베이스는 그 데이터가 저장된 16KB짜리 페이지 전체를 디스크에서 읽어옴(InnoDB 스토리지 엔진 기본값: 16KB)

즉, **하나의 페이지에 내가 필요한 데이터가 얼마나 오밀조밀하게 모여 있느냐**가 쿼리 성능을 좌우함

## 인덱스(Index)

데이터베이스 테이블의 **검색 속도를 높이기 위한** 별도의 **자료구조**

### 구조 (Key, Value)

데이터베이스는 우리가 찾는 데이터가 디스크의 어느 주소에 있는지 바로 알 수 없음. 그래서 인덱스라는 별도의 페이지(파일)를 만들어 두고, **"이 데이터는 디스크의 몇 번 주소에 있어"**라고 기록해 둠

인덱스는 기본적으로 Key-Value 구조로 되어 있음:
- **Key**: 인덱스 컬럼의 값 (예: `user_id = 100`)
- **Value**: 해당 데이터의 위치 정보
  - 클러스터링 인덱스: 실제 데이터 페이지 자체
  - 세컨더리 인덱스: 해당 레코드의 PK 값

### 특징

- 인덱스는 항상 정렬된 상태를 유지 (정렬이 되어 있어야만 처음부터 끝까지(Full Scan) 뒤지지 않고, 중간을 찔러서 찾는 탐색(Binary Search 등)이 가능)
- 데이터 파일은 데이터가 들어온 순서대로 저장될 뿐, 정렬되지 않음

### 트레이드 오프

**장점:**
- 이미 정렬되어 있으므로 원하는 값을 아주 빠르게 찾아낼 수 있음
- SELECT 쿼리 성능 향상

**단점:**
- **INSERT**: 새로운 데이터가 들어오면, 인덱스는 정렬 순서를 지키기 위해 적절한 위치를 찾아 값을 넣고 뒤의 값들을 밀어내는 등 **추가 작업**이 필요
- **UPDATE**: 인덱스 컬럼 값이 변경되면 인덱스도 함께 수정해야 함
- **DELETE**: 실제로 데이터를 즉시 물리적으로 삭제하지 않고, "삭제 마크"만 표시하는 방식으로 동작함 (트랜잭션 관리 및 성능을 위해). 나중에 백그라운드 프로세스가 실제 정리를 수행하지만, 이로 인해 인덱스에 빈 공간(fragmentation)이 생겨 점차 성능 저하가 발생할 수 있음
- 인덱스 자체가 디스크 공간을 차지함

## B-Tree 인덱스

MySQL에서 B-Tree(Balanced Tree) 인덱스는 가장 범용적으로 사용되는 인덱스 자료구조 (InnoDB는 B-Tree의 확장형인 B+Tree 구조를 사용)

### B-Tree 구조

- **루트 노드** (Root Node): 트리의 최상위에 있는 노드(탐색의 시작점)
- **브랜치 노드** (Branch Node): 루트와 리프 사이의 중간 다리 역할을 하며, 경로를 안내
- **리프 노드** (Leaf Node): 트리의 가장 하단에 위치하며, 실제 데이터 레코드의 주소(또는 데이터 자체)를 가지고 있음

#### B+Tree 특징

1. 데이터는 오직 리프 노드에만 저장 - 루트와 브랜치 노드는 데이터를 찾기 위한 '이정표(Key)' 역할만 함. 이로 인해 한 노드에 더 많은 키를 담을 수 있어 트리의 높이가 낮아짐
2. 리프 노드는 연결 리스트 구조 - 모든 리프 노드는 서로 양방향으로 연결(Linked List)로 되어 있음. 덕분에 범위 검색에 효율적

### 작동 원리 (데이터 조작 시)

검색 (SELECT) - O(log N): 

데이터를 찾을 때, 루트 노드부터 시작해서 자식 노드로 내려가며 탐색. **트리의 높이만큼만 비교**하면 되므로 데이터가 아무리 많아도 매우 빠르게 찾을 수 있음.

저장 및 수정 (INSERT, UPDATE, DELETE) - 비용 발생

인덱스는 **'정렬된 상태'**를 유지해야 한다는 비용이 발생함.

## 클러스터링 인덱스 (Clustered Index)

**실제 데이터가 인덱스 순서대로 정렬**되어 저장되는 인덱스

### 특징

- InnoDB에서는 PK(Primary Key)가 자동으로 클러스터링 인덱스가 됨
- 테이블당 **오직 1개**만 가질 수 있음 (데이터를 물리적으로 한 가지 순서로만 정렬할 수 있기 때문)
- Leaf Node에 **실제 데이터 페이지 전체**가 저장됨
- PK로 검색 시 추가 탐색 없이 바로 데이터 접근 가능 → **매우 빠름**

### PK 선택이 중요한 이유

- PK 값에 따라 물리적 데이터 배치가 결정됨
- **PK가 순차적**(예: AUTO_INCREMENT)이면 INSERT 시 페이지 끝에 데이터를 추가하기만 하면 되므로 성능이 좋음
- **PK가 랜덤**(예: UUID)이면 INSERT 시 페이지 중간에 데이터를 끼워넣어야 하므로:
  - 기존 데이터를 이동시켜야 함
  - 페이지 분할(Page Split) 발생 가능
  - 성능 저하 및 디스크 공간 낭비

## 세컨더리 인덱스 (Secondary Index)

PK가 아닌 다른 컬럼에 생성하는 인덱스

### 특징

- 테이블당 **여러 개** 생성 가능
- Leaf Node에 **실제 데이터가 아닌 PK 값**을 저장
- 데이터 조회 시 2단계 필요:
  1. 세컨더리 인덱스에서 PK 값 찾기
  2. PK로 클러스터링 인덱스에서 실제 데이터 찾기 (**북마크 룩업, Bookmark Lookup**)

### 왜 데이터 주소 대신 PK를 저장하나?

- 클러스터링 인덱스는 데이터가 PK 순서대로 정렬되어 있어서, INSERT/DELETE 시 데이터의 물리적 위치가 변경될 수 있음
- 만약 세컨더리 인덱스가 물리적 주소를 저장한다면, 데이터 이동 시마다 모든 세컨더리 인덱스를 수정해야 함
- PK는 변하지 않으므로, PK를 저장하면 데이터가 이동해도 세컨더리 인덱스는 수정할 필요가 없음 → 안정적이고 유지보수 비용이 낮음

### 세컨더리 인덱스 사용 예시
```sql
-- user_name에 세컨더리 인덱스가 있다고 가정
SELECT * FROM users WHERE user_name = 'John';

-- 실행 과정:
-- 1. user_name 세컨더리 인덱스에서 'John'을 찾음 → PK 값(예: 100) 확인
-- 2. PK 값 100으로 클러스터링 인덱스를 탐색해 실제 데이터 조회
```

### 클러스터링 vs 세컨더리 인덱스 비교

| 구분 | 클러스터링 인덱스 | 세컨더리 인덱스 |
|------|------------------|----------------|
| 개수 | 테이블당 1개 | 테이블당 여러 개 |
| Leaf Node | 실제 데이터 | PK 값 |
| 검색 속도 | 매우 빠름 (1단계) | 상대적으로 느림 (2단계) |
| 데이터 정렬 | PK 순서로 물리적 정렬 | 데이터 정렬과 무관 |