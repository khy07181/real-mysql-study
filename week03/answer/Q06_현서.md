# B-Tree 선택도

## 1. 인덱스 선택도(Selectivity)와 카디널리티(Cardinality)

인덱스에서 카디널리티와 선택도는 보통 같은 의미로 통용되며, 인덱스 키값 가운데 유니크한 값의 수를 말합니다. 인덱스는 유니크한 값의 개수가 많을수록(카디널리티가 높을수록) 검색 대상을 잘 걸러내기 때문에 효율적입니다.

### 카디널리티 수준별 예시
- 주민등록번호 / ID: 모든 값이 고유함. 카디널리티가 최대치이며 최고의 효율을 보임.
- 키 (Height): 소수점 단위까지 존재하여 겹치는 값이 매우 적음. 카디널리티가 높으며 효율적임.
- 성씨 (Family Name): 김, 이, 박 등 겹치는 경우가 존재함. 카디널리티 중간 수준.
- 성별 (Gender): 값의 종류가 남/여 2개뿐임. 카디널리티가 매우 낮으며 인덱스 효율이 극도로 떨어짐.

---

## 2. 인덱스 사용의 임계점: 20~25% 규칙

인덱스를 사용하는 것이 항상 최선은 아닙니다. 인덱스를 통한 데이터 조회는 인덱스 트리 탐색 비용과 본 테이블 접근을 위한 Random I/O 비용이 발생하기 때문입니다.

- 비용 판단: 일반적으로 인덱스를 통해 레코드 1건을 읽는 것은 테이블에서 직접 읽는 것보다 4~5배 정도 더 많은 비용이 드는 것으로 예측합니다.
- 효율성 한계: 읽어야 할 레코드 건수가 전체 테이블 레코드의 약 20~25%를 넘어서면, 인덱스를 무시하고 테이블 전체를 읽는 방식(Full Table Scan)이 더 효율적입니다.

---

## 3. 낮은 카디널리티의 구체적 사례 (주문 테이블)

1,000,000건의 레코드가 있는 테이블에서 주문_상태(결제대기, 배송중, 배송완료) 컬럼에 인덱스를 만든 경우를 가정해 봅니다.

- 상황: 각 상태의 데이터 비율이 균등하게 1/3(약 33.3%)씩 존재
- 검색: WHERE 주문_상태 = '결제대기' 쿼리 실행
- 인덱스 활용 시: 전체의 33.3%인 약 33만 건을 인덱스를 통해 찾아야 함 (Random I/O 33만 번 발생)
- 최종 선택: 읽어야 할 데이터가 25%를 초과하므로, 옵티마이저는 인덱스를 무시하고 풀 테이블 스캔으로 데이터를 가져오는 것이 더 효율적이라고 판단합니다.

---

## 4. 인덱스 설계가 중요한 이유 (옵티마이저와 성능의 관계)

인덱스가 있다고 해서 항상 효율적인 것은 아니지만, 인덱스가 존재하면 옵티마이저는 이를 사용하려고 시도할 가능성이 높습니다. 잘못 설계된 인덱스는 다음과 같은 문제를 일으킬 수 있습니다.

- 부적절한 실행 계획 유도: 실제로는 풀 테이블 스캔이 빠름에도 불구하고, 옵티마이저가 인덱스를 잘못 선택하여 쿼리 성능이 저하될 수 있습니다.
- 쓰기 성능 저하: 인덱스는 데이터의 삽입, 수정, 삭제(DML) 성능을 떨어뜨립니다.
- 저장 공간 낭비: 활용도가 낮은 인덱스는 디스크 공간과 메모리(Buffer Pool)를 불필요하게 점유합니다.



---

## 5. 카디널리티 외 설계 시 고려해야 할 추가 요소(추가로 알면 좋을 것 같아서 AI 내용 추가)

성공적인 인덱스 설계를 위해서는 카디널리티뿐만 아니라 다음과 같은 요소를 종합적으로 고려해야 합니다.

### ① 쿼리의 실행 빈도 및 중요도
- 아무리 선택도가 좋아도 1년에 한 번 쓰는 쿼리를 위해 인덱스를 만드는 것은 비효율적일 수 있습니다.
- 반대로 선택도가 조금 낮더라도 하루에 수백만 번 실행되는 핵심 비즈니스 쿼리라면 인덱스 설계를 정교하게 다듬어야 합니다.

### ② 데이터 변경(DML) 빈도
- 데이터가 빈번하게 삽입되거나 수정되는 테이블에 인덱스가 많으면 성능 부하가 심해집니다.
- 읽기 전용 테이블인지, 쓰기가 빈번한 테이블인지에 따라 인덱스 개수를 조절해야 합니다.

### ③ 복합 인덱스의 컬럼 순서
- 여러 컬럼으로 인덱스를 만들 때는 작업 범위 결정 조건으로 쓰일 컬럼, 즉 카디널리티가 높은 컬럼을 앞순서에 배치하는 것이 유리합니다.

### ④ 데이터 타입 및 크기
- 인덱스 키의 크기가 커지면 인덱스 페이지 하나에 담을 수 있는 키의 개수가 적어집니다. 이는 B-Tree의 깊이를 깊게 만들어 탐색 효율을 떨어뜨리므로, 가능한 작은 데이터 타입을 선택하는 것이 좋습니다.

---

## 6. 결론
인덱스 설계의 핵심은 효율적인 카디널리티를 확보하는 것과 시스템의 전체적인 밸런스(읽기 vs 쓰기)를 맞추는 것입니다. 무분별한 인덱스 생성보다는 실행 계획을 분석하여 최적의 경로를 설계하는 것이 중요합니다.
