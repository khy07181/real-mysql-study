# MySQL의 4가지 트랜잭션 격리 수준을 나열하고, 각각에서 발생할 수 있는 문제점을 설명하세요.

## 1. READ UNCOMMITTED (커밋되지 않은 읽기)

가장 낮은 격리 수준으로, 트랜잭션이 커밋되지 않은 데이터도 읽을 수 있습니다.

**발생 가능한 문제:**
- **Dirty Read**: 다른 트랜잭션이 수정했지만 아직 커밋하지 않은 데이터를 읽을 수 있습니다. 만약 해당 트랜잭션이 롤백되면 무효한 데이터를 읽게 됩니다.
- **Non-Repeatable Read**: 같은 쿼리를 두 번 실행했을 때 다른 결과가 나올 수 있습니다.
- **Phantom Read**: 범위 조건으로 조회 시, 다른 트랜잭션이 새로운 행을 추가하면 이전에 없던 데이터가 나타날 수 있습니다.

## 2. READ COMMITTED (커밋된 읽기)

커밋된 데이터만 읽을 수 있는 수준입니다. 대부분의 DBMS에서 기본값으로 사용됩니다(Oracle, PostgreSQL 등).

**발생 가능한 문제:**
- **Non-Repeatable Read**: 트랜잭션 내에서 같은 데이터를 두 번 조회할 때, 그 사이에 다른 트랜잭션이 해당 데이터를 수정하고 커밋하면 다른 값을 읽게 됩니다.
- **Phantom Read**: 같은 조건으로 조회했는데 다른 트랜잭션이 새로운 행을 추가하거나 삭제하면 결과 집합이 달라집니다.

## 3. REPEATABLE READ (반복 가능한 읽기)

MySQL InnoDB의 기본 격리 수준입니다. 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 항상 같은 결과를 보장합니다.

**발생 가능한 문제:**
- **Phantom Read**: 표준 SQL에서는 이 문제가 발생할 수 있습니다. 하지만 MySQL InnoDB는 MVCC와 넥스트 키 락(Next-Key Lock)을 사용하여 팬텀 리드도 대부분 방지합니다.
- **Lost Update**: 동시에 같은 데이터를 수정하려는 경우 마지막 업데이트만 반영될 수 있습니다(적절한 락을 사용하지 않을 경우).

## 4. SERIALIZABLE (직렬화 가능)

가장 높은 격리 수준으로, 트랜잭션을 순차적으로 실행하는 것과 같은 효과를 냅니다.

**발생 가능한 문제:**
- 이론적으로는 위의 모든 문제가 발생하지 않습니다.
- 하지만 **성능 저하**가 심각합니다. 모든 SELECT 문에 공유 락이 걸리고, 동시성이 크게 떨어집니다.
- **데드락** 발생 가능성이 높아집니다.
- **타임아웃**이 자주 발생할 수 있습니다.