# MySQL InnoDB의 기본 격리 수준인 REPEATABLE READ에서 Phantom Read가 발생하지 않는 이유를 설명하세요.

MySQL InnoDB의 REPEATABLE READ에서 Phantom Read가 발생하지 않는 이유는 **Next-Key Lock**을 사용하기 때문입니다.

## Next-Key Lock의 동작 원리

Next-Key Lock은 **Record Lock + Gap Lock**의 조합입니다:

- **Record Lock**: 실제 인덱스 레코드 자체를 잠금
- **Gap Lock**: 인덱스 레코드 사이의 "간격"을 잠금

예를 들어, id가 10, 20, 30인 레코드가 있을 때:
- Record Lock: 10, 20, 30 각 레코드를 잠금
- Gap Lock: (∞, 10), (10, 20), (20, 30), (30, ∞) 범위를 잠금

## Phantom Read 방지 메커니즘

```sql
-- Transaction A
START TRANSACTION;
SELECT * FROM users WHERE age BETWEEN 20 AND 30; 
-- 결과: id=5 (age=25), id=8 (age=28)
```

이 시점에서 InnoDB는:
1. age가 20~30 범위의 레코드에 Record Lock 설정
2. 해당 범위의 Gap에도 Gap Lock 설정

```sql
-- Transaction B (동시 실행)
INSERT INTO users (id, age) VALUES (10, 27); 
-- Gap Lock 때문에 대기(blocked)
```

Transaction B의 INSERT는 age=27이 기존 레코드 사이의 gap에 해당하므로, Transaction A가 설정한 Gap Lock과 충돌하여 **대기 상태**가 됩니다.

```sql
-- Transaction A
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- 여전히 같은 결과: id=5, id=8
COMMIT;
```

## 일반적인 REPEATABLE READ와의 차이

표준 SQL의 REPEATABLE READ는 Record Lock만 사용하여:
- 같은 행을 다시 읽으면 같은 값 보장
- 하지만 새로운 행의 삽입은 막지 못함 (Phantom Read 발생)

InnoDB의 REPEATABLE READ는 Gap Lock 추가로:
- 범위 내 새로운 행의 삽입까지 차단
- Phantom Read까지 방지

## 추가 고려사항

Gap Lock은 인덱스를 사용하는 쿼리에만 적용됩니다:
- 인덱스가 없는 컬럼으로 조회 시 테이블 전체를 스캔하며 더 넓은 범위에 잠금 발생
- 성능을 위해 적절한 인덱스 설계가 중요