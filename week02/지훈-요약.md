# 5장 트랜잭션과 잠금

# **트랜잭션**

> 작업의 완전성을 보장해준다 (ACID 중 Atomicity(원자성))
>
- InnoDB 스토리지 엔진을 제외한 MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않음
- 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구하여 작업의 일부만 적용되는 현상을 막아준다
    - 하나의 논리적입 작업 셋에는 하나의 쿼리가 있든 여러 개의 쿼리가 있든 관계 없다
    - 단지 논리적인 작업 셋이 100% 적용(Commit) or 0% 적용(RollBack)

**주의점**

- 프로그램 코드에서 트랜잭션의 범위를 최소화 해야 한다

    ```
    1. 처리 시작
     ==> 데이터베이스 커넥션 생성
     ==> 트랜잭션 시작
    2. 사용자의 로그인 여부 확인  // 확인을 하는 2, 3번이 아무리 빨리 끝나더라도 트랜잭션에 포함할 필요가 있나?
    3. 사용자의 글쓰기 내용의 오류 여부 확인
    4. 첨부로 업로드된 파일 확인 및 저장
    5. 사용자의 입력 내용을 DBMS에 저장 // DB에 데이터를 저장 시작
    6. 첨부 파일 정보를 DBMS에 저장
    7. 저장된 내용 또는 기타 정보를 DBMS에 저장 // 이미 저장한 정보를 다시 확인하는데 트랜잭션에 포함할 필요가 있나?
    8. 게시물 등록에 대한 알림 메일 발송 // 외부 네트워크 통신이 오래걸리거나 오류가 발생할 수 있음
    9. 알림 메일 발송 이력을 DBMS에 저장
     <== 트랜잭션 종료
     <== 데이터베이스 커넥션 반남
    10. 처리 완료
    
    ```

    - DB 커넥션과 동일하게 최소한의 범위만 가져가야 안전하다
    - 일반적으로 DB 커넥션은 개수가 제한적이다
    - 근데 만약 트랜잭션 내부에서 외부 네트워크 통신 작업을 진행할 경우… 응답에 문제가 생겼으면 해당 트랜잭션에서는 DB 커넥션을 무한정 물고 있을 것이다 → DB 서버가 위험해짐
- 작업의 완전성을 보장하기 위한 기능
    - 레코드에 대해 여러 커넥션이 변경을 시도를 허용하면 값을 예측하기가 어려움
    - 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있는 역할


# **MySQL 엔진과 스토리지 엔진의 잠금**

- MySQL 엔진 레벨의 잠금 : 모든 스토리지 엔진에 영향
- 스토리지 엔진 레벨의 잠금 : 해당 스토리지 엔진에만 영향 (스토리지 엔진 간 상호 영향 X)

## **MySQL 엔진의 잠금**

### **글로벌 락 (GLOBAL LOCK)**

- 영향 범위 = MySQL 서버 전체
    - 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향
    - 글로벌 락은 가급적 사용하지 않는 것을 권장
- 한 세션에서 글로벌 락을 획득할 경우 SELECT를 제외한 대부분의 DDL, DML 문장을 실행하는 동안 대기
- 용도
    - 여러 데이터베이스에 있는 MyISAM, MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받을 때 글로벌 락을 사용
    - mysqldump 명령어는 내부적으로 `FLUSH TABLES WITH READ LOCK`를 실행할 수 있으므로 사용 옵션을 확인
- `FLUSH TABLES WITH READ LOCK` 을 통해 락을 획득할 수 있음
    - 서버에 존재하는 모든 테이블을 닫고 잠금
    - 테이블의 읽기 잠금을 걸기 위해 이미 실행된 테이블, 레코드 쓰기 트랜잭션의 완료를 위해 대기
        - 잠금을 걸기 전에 테이블을 플러시해야 하기 때문에 실행중인 모든 종류의 쿼리가 완료되어야 함
- InnoDB는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 작업을 멈출 필요가 없음
  → MySQL 8.0부터 가벼운 글로벌 락에 필요성이 커짐
    - Xtrabackup, Enterprise Backup 등과 같은 툴들의 안정적인 실행을 위해 백업 락 도입
    - 특정 세션이 백업 락을 획득하면 다음과 같은 작업이 불가
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
        - REPAIR TABLE과 OPTIMIZE TABLE 명령
        - 사용자 관리 및 비밀번호 변경
    - 백업 락은 일반적으로 테이블의 데이터 변경은 허용

### **테이블 락 (TABLE LOCK)**

- 영향 범위 = 개별 테이블
- 명시적, 묵시적으로 특정 테이블의 락 획득 가능
    - 명시적,
        - `LOCK TABLES table_name [READ | WRITE]` 명령을 통해 획득
        - `UNLOCK TABLES`를 통해 반납(해제)
    - 묵시적
        - MyISAM, MEMORY 테이블 데이터를 변경하는 쿼리를 실행하면 발생
        - 데이터 변경 후에 즉시 잠금 해제
    - nnoDB 테이블은 스토리지 엔진이 기본적으로 레코드 기반 잠금을 제공하므로,
      단순 데이터 변경 쿼리 실행 시 `테이블 락`이 설정되어도 DML 쿼리에서는 무시된다
      (DDL만 영향을 미침)

### **네임드 락 (NAMED LOCK)**

```
// "mylock" 이라는 문자열 잠금 획득
// 이미 잠금을 사용 중이면 2초 대기, 2초 이후 자동 잠금 해제
mysql> SELECT GET_LOCK('mylock', 2);

// "mylock"이라는 문자열에 대해 잠금 확인
mysql> SELECT IF_FREE_LOCK('mylock');

// "mylock"이라는 문자열에 대해 획득했던 잠금 반납
mysql> select RELEASE_LOCK('mysql');

// 위의 3개 함수 모두 정상적으로 성공하면 1, 아니면 null, 0 반환

```

- `GET_LOCK()` 함수를 이용하여 문자열에 대해 잠금을 설정
- 네임드 락의 잠금 대상은 데이터베이스 객체(테이블, 레코드, AUTO_INCREAMENT 등)가 아니다
    - 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금
- 네임드 락은 자주 사용되지는 않지만 배치 프로그램에서는 유용하게 사용될 수 있다
    - 한꺼번에 많은 레코드를 변경하는 쿼리 실행 시 데드락이 자주 발생됨
    - 이 때 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 데드락이 효과적으로 회피됨
- 또한 MySQL 8.0 부터 네임드 락 중첩 사용 가능 및 현재 세션에서 획득한 네임드 락을 일괄 해제 가능

### **메타데이터 락 (METADATA LOCK)**

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금
- 명시적으로 획득하고 해제하는 락이 아님
    - `RENAME TABLE tab_a TO tab_b` 같이 테이블 이름을 변경하는 경우 자동 획득
        - 원본 이름과 변경될 이름 두개 모두 한꺼번에 잠금
        - 실시간으로 테이블 변경의 경우 `RENAME TABLE rank TO rank_backup, rank_new TO rank;` 를 활용하면 좋음
            - 2개로 분리해서 실행할 경우 rank 테이블을 찾을 수 없다는 오류가 순간 생길 수 있음

## **InnoDB 스토리지 엔진 잠금**

![image.png](https://github.com/user-attachments/assets/e1d6e05b-3817-431f-85d9-037093f41980)

- 내부에 레코드 기반의 잠금 방식 탑재
    - 레코드 기반의 잠금이기에 MyISAM 보다 훨씬 뛰어난 동시성 처리 제공
- 잠금 정보는 상당히 작은 공간으로 관리되므로 `레코드 락`이 `페이지 락`이나 `테이블 락`으로 레벨업되는 경우는 없다.
- 최근에는 트랜잭션, 잠금, 잠금 대기중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입
    - 원래는 `SHOW ENGINE INNODB STATUS` 명령어 뿐이었음
    - `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS`라는 테이블을 조인해서 조회하면 확인 가능
    - InnoDB의 잠금에 대한 모니터링도 강화되어 Performance Schema를 이용해 내부 잠금에 대한 모니터링 방법도 추가

### **레코드 락 (Record lock)**

- 레코드 자체만을 잠금
- **정확히는 레코드 자체가 아니라 인덱스의 레코드를 잠금!**
    - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터링 인덱스를 이용해 잠금
- 보조 인덱스를 이용한 대부분의 변경 작업은 `넥스트 키 락` 또는 `갭 락`을 사용
    - 하지만! 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업은
      `갭 락`, `넥스트 키 락` 없이 레코드 자체에만 락을 건다

### **갭 락(Gap lock)**

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
- 넥스트 키 락(Next key lock)의 일부로 자주 사용
- 부가설명

  > 쿼리에서 범위가 지정되어 있을 때, 해당 범위에 있는 Index Record 중 테이블에 존재하지 않는  범위에 걸리는 Lock
  >
  > - 만약 테이블에 1,2 가 들어가 있을 때
      > 테이블에서 1이상 5 이하인 데이터를 조회한다면
      > 1~5사이에 있고 인덱스 테이블에 존재하지 않는 3,4,5에 GapLock이 걸린다.
  > - 인덱스 레코드와 인접한 앞/뒤 사이 공간에 락을 거는 것
  > - **record lock이 이미 존재하는 row가 변경되지 않도록 보호**하는 반면, 
    > **gap lock은 조건에 해당하는 새로운 row가 추가되는 것을 방지하기 위함**이다.

### **넥스트 키 락(Next key lock)**

- `레코드 락` + `갭 락`을 합쳐놓은 형태의 잠금
- 주 목적
    - 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 떄(복제 될 떄) 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것
- 하지만 의외로 `넥스트 키 락`과 `갭 락`으로 인해 데드락이 발생하거나, 다른 트랜잭션을 기다리게 만드는 일이 자주 발생
    - 따라서 가능하면 `바이너리 로그 포맷` 보다는 `ROW 형태`로 바꿔서 넥스트 키 락이나 갭 락을 줄이자!
- MySQL 5.5 까지는 ROW 포맷의 바이너리 로그가 도입된지 별로 안돼 널리 사용이 안됐음
    - 하지만 8.0부터 업그레이드 되어 ROW 포맷의 바이너리 로그에 대한 안정성 증가
    - 또한 기존 STATEMENT 포맷(쿼리문 형식)의 바이너리 로그의 단점을 많이 해결해줄 수 있어 MySQL 8.0 부터 ROW 형식이 default
- 부가설명

  ![img2](https://github.com/user-attachments/assets/3bc7e0d7-04e1-4ca8-bb71-248a351134cc)

  https://www.letmecompile.com/mysql-innodb-lock-deadlock/


### **자동 증가 락**

- `AUTO_INCREAMENT 락`이라고 하는 테이블 수준의 잠금
- 새로운 레코드를 저장하는 쿼리(INSERT, REPLACE) 에서만 필요
    - UPDATE, DELETE는 필요하지 않음
    - REPLACE : 없으면 INSERT, 있으면 DELETE 후 INSERT
- 트랜잭션과 관계 없이 새 레코드 저장 쿼리에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
- MySQL 5.1 이상부터 시스템 변수 `innodb_autoinc_lock_mode`를 통해 자동 증가 락의 작동 방식 변경 가능
    - `innodb_autoinc_lock_mode = 0` : 기존 모드
        - 기존 잠금 방식 : 모든 INSERT 문장은 자동 증가 락을 사용
    - `innodb_autoinc_lock_mode = 1` : 연속 모드
        - **단순 한건 또는 레코드의 건수가 정확히 예측 가능한 여러 건인 경우**
            - 자동 증가 락 대신 경량화된 래치(뮤텍스)를 이용해서 처리 (아주 짧은 시간 동안만 잠금을 걸고 자동 증가 값을 가져옴)
        - **건수를 예측할 수 없는 경우**
            - 자동 증가 락을 사용하지만, 여러 개의 자동 증가 값을 한번에 할당
            - INSERT 되는 레코드는 연속된 자동 증가 값을 보장받지만, 사용되지 못한 자동 증가 값은 폐기된다
    - `innodb_autoinc_lock_mode = 2` : 빠른 모드
        - 절대 자동 증가 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용
        - 연속된 값을 보장하지는 않고, 유니크한 값이 생성된다는 것만 보장
        - 만약 해당 모드에서 STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있다
            - 복제 환경에서는 raw 포맷을 사용해야 될 듯

## **인덱스와 잠금**

- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락

    ```
    // test1만 index가 걸려 있음
    mysql> UPDATE ??? SET date = NOW() WHERE test1 = 'A' AND test2 = 'B'
    
    ```

    - 데이터 변경을 위해 검색 조건으로 test1, test2 가 존재
- test2는 인덱스가 없기 때문에 test1 인덱스 값에 해당하는 'A' 인 레코드는 모두 락
- UPDATE 작업을 위한 적절한 인덱스가 없다면 각 클라이언트 간의 동시성이 상당히 떨어져서 다른 클라이언트는 테이블에 대해 대기하는 상황이 발생할 수 있음
- 테이블에 인덱스가 하나도 없다면? → 풀 스캔( 테이블에 있는 모든 레코드를 락)
- 부가설명
    - InnoDB는 레코드 단위로 Lock을 걸 때, 실제 레코드 1개가 아닌 Index 레코드 단위로 Lock을 건다.
    - 이렇게 될것같지만 사실은...

      ![Untitled](https://github.com/user-attachments/assets/de7858f6-f6c7-4f1b-bae7-2ff5a5729fe0)

    - 인덱스를 기준으로 락이 걸린다.

      ![Untitled](https://github.com/user-attachments/assets/6c004e34-5073-461c-9a85-4a34b91c95da)


# **MySQL의 격리 수준**

- 여러 트랜잭션이 동시에 처리될 경우 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정
- MySQL 에서는 REPEATABLE READ, Oracle 에서는 READ COMMITTED가 기본 값

## 부정합 문제(낮은 Isolation Level에서 발생하는 문제)

![untitled](https://github.com/user-attachments/assets/5a5c30b2-c71b-4ce6-8783-6990f356b5fc)

https://jumpegg.github.io/2017/07/15/mysql-transection3/

### Dirty Read

![Untitled](https://github.com/user-attachments/assets/5ab793a4-10f8-4b8a-bfcd-46d39cfe1d28)

<aside>
💡 **다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것**

</aside>

- Transaction1에서 아직 Commit하지 않은 데이터를 Transaction2가 읽는 경우,
  만약 Transaction1이 롤백된다면 해당 데이터는 존재하지 않는 데이터 일 것이다.
  하지만 Transaction2는 이미 그 데이터를 읽은 상태이고
  잘못된 값을 가지고 로직을 처리하게 된다.

### Non-Repeatable Read

![Untitled](https://github.com/user-attachments/assets/96444782-c7de-47be-94f1-ee3df249fc56)

<aside>
💡 **한 트랜잭션 내에서 같은 Key를 가진 Row를 두 번 읽었는데 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상**

</aside>

- Transaction2에서 첫번쨰 조회할때는 SABARADA였는데,
  두번쨰로 조회할떄는 YHX이다.
  첫번째 조회와 두번쨰 조회 사이에 데이터의 변경이 일어나서 이러한 현상이 발생한다.

### Phantom Read

![Untitled](https://github.com/user-attachments/assets/cb3b3405-cb05-4688-8b11-6fb1d75e5787)

<aside>
💡 **한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상**

</aside>

- Transaction2에서 첫번쨰 조회 할 때, 없던 데이터가 두번쨰 조회 시 생성되어있다.
  첫번쨰 조회와 두번쨰 조회 사이에 데이터가 Insert되었기 때문에 이러한 문제가 발생한다.

## 격리수준

### **READ UNCOMMITTED**

> 각 트랜잭션에서의 변경 내용이 COMMIT과 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보이는 레벨
>
- 커밋되지 않은 상태에서도 이미 다른 트랜잭션에서는 변경된 데이터가 보임 (`DIRTY READ`)
- 이 말은 즉슨 롤백돼서 유효한 데이터가 아닌데도 다른 트랜잭션에서 사용될 가능성이 높음
- 데이터 정합성에 문제가 많은 격리 수준이다

### **READ COMMITTED**

> 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트렌젝션에서 조회할 수 있는 레벨
>
- `DIRTY READ`가 발생하지 않음, 대신 `NON-REPEATABLE READ` 발생
    - A 트랜잭션에서 SELECT를 두번 실행
    - B 트랜잭션에서 A 트랜잭션의 SELECT 사이에 INSERT를 COMMIT
    - A 트랜잭션에서 두번째 SELECT는 INSERT된 데이터 접근 가능
- 트랜잭션 수행 중에 다른 트랜잭션에 의한 COMMIT 완료가 일어나면 데이터 접근 범위에 대한 일관성이 떨어짐

### **REPEATABLE READ**

(MySQL의 InnoDB 스토리지 엔진 기본 격리 수준)

> MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해
동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장
>
- MySQL 서버에서는 최소 `REPEATABLE READ` 이상의 격리수준을 가져야 한다.
- `REPEATABLE READ`와 `READ COMMITTED`의 차이
    - 언두 영역에 백업된 여러 버전 가운데 몇번째 이전의 버전까지 찾아들어가야 하느냐에 있다.
- `REPEATABLE READ` 격리수준은 MVCC를 보장하기 위해 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두영역의 데이터는 삭제할 수 없다. (특정 트랜잭션 번호구간 내에서 백업된 언두 데이터가 필요)
- InnoDB에서는 `NEXT KEY LOCK`으로 `REPEATABLE READ`를 보장하기 때문에 `PHANTOM READ`가 발생하지 않는다.
  (책에서는 발생한다고 `PHANTOM READ`가 나옴! 하지만 아래 자료를 보면 아님)

  ![untitled](https://github.com/user-attachments/assets/228d90a7-0a85-4e6a-b36f-8a0ed2bade69)

  https://jumpegg.github.io/2017/07/15/mysql-transection3/


**예시**

![image.png](https://github.com/user-attachments/assets/9af71eac-dec5-444c-b6e5-29219810995b)

- 사용자 B가 트랜잭션 시작 (트랜잭션 ID 10)
- 사용자 B가 emp_no가 500000인 데이터 조회 (Lara)
- 사용자 A가 트랜잭션 시작 (트랜잭션 ID 12)
- 사용자 A가 emp_no가 500000인 데이터를 Toto로 변경
- 사용자 A가 변경하기 전 데이터는 UNDO 영역에 저장된다. (트랜잭션 ID 6)
- 사용자 B가 emp_no가 500000인 데이터 조회. 이때 사용자 B의 트랜잭션 ID 보다 낮은 트랜잭션 ID의 레코드만 조회할 수 있게 된다.
- 사용자 A는 트랜잭션 ID는 12 이므로 사용자 B는 사용자 A가 수정한 데이터를 확인할 수 없다. 그러므로 결과는 동일하게 Lara가 응답된다.

### **SERIALIZABLE**

> 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 레벨
>
- 트랜잭션 격리수준이 **SERIALIZABLE**로 설정되면 읽기 작업도 잠금을 획득해야 한다.